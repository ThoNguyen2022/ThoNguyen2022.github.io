<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Leak Search Tool</title>
  <style>
    .spinner {
      width: 24px;
      height: 24px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: inline-block;
      vertical-align: middle;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #results, #statusMessage {
      display: none;
      margin-top: 20px;
    }

    table {
      border-collapse: collapse;
      width: 100%;
    }

    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }

    th {
      background-color: #f4f4f4;
    }
  </style>
</head>
<body>
  <h2>Leak Search Tool</h2>
  <textarea id="keywords" rows="10" cols="60" placeholder="Line 1: Access Token&#10;Line 2+: Keywords, one per line"></textarea><br><br>
  <button onclick="runSearch()">Run Search</button>

  <div id="statusMessage"></div>
  
  <table id="results">
    <thead>
      <tr>
        <th>No</th>
        <th>Keyword</th>
        <th>Status</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    async function fetchWithRetry(url, headers, retries = 3, delay = 3000) {
      for (let attempt = 1; attempt <= retries; attempt++) {
        try {
          let res = await fetch(url, { headers });

          let remaining = res.headers.get("X-RateLimit-Remaining");
          let resetTime = res.headers.get("X-RateLimit-Reset");

          if (remaining === "0") {
            const waitMillis = (parseInt(resetTime, 10) * 1000) - Date.now();
            const waitSeconds = Math.ceil(waitMillis / 1000);
            const resetDate = new Date(parseInt(resetTime, 10) * 1000).toLocaleString();

            showStatusMessage(`Rate limited. Waiting ${waitSeconds} seconds until ${resetDate}...`, true);
            await delayExecution(waitMillis);

            res = await fetch(url, { headers });
          }

          if (!res.ok) {
            if (res.status === 403) {
              const retryAfter = res.headers.get("Retry-After");
              if (retryAfter) return { error: `Rate limited. Retry after ${parseInt(retryAfter, 10)} seconds.` };
            }
            throw new Error(`HTTP ${res.status}`);
          }

          return await res.json();
        } catch (error) {
          if (attempt === retries) throw error;

          showStatusMessage(`Retrying in ${delay / 1000} seconds...`, true);
          await delayExecution(delay);
        }
      }
    }

    async function runSearch() {
      const lines = getInputLines();
      if (lines.length < 2) return alert("Please enter access token in the first line and at least one keyword.");

      const token = lines[0].trim();
      const keywords = lines.slice(1);

      toggleVisibility(false);
      showStatusMessage("Running search...", true);

      const headers = {
        "Authorization": "Bearer " + token,
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
      };

      for (let i = 0; i < keywords.length; i++) {
        await processKeyword(i, keywords[i], headers);
      }

      showStatusMessage("Done.", false);
    }

    async function processKeyword(index, keyword, headers) {
      const encoded = encodeURIComponent(keyword);
      const url = `https://api.github.com/search/code?q=${encoded}`;

      let status = "Checking...";
      let link = "-";

      try {
        const data = await fetchWithRetry(url, headers);
        if (data.error) {
          status = data.error;
          link = "-";
          if (data.error.includes("Rate limited")) return showStatusMessage(data.error, false);
        } else {
          status = data.total_count > 0 ? "Possible Leak" : "No Leak";
          link = data.total_count > 0 ? `<a href="https://github.com/search?q=${encoded}" target="_blank">Check</a>` : "-";
        }
      } catch (err) {
        status = "Error: " + (err.message || "Unknown");
      }

      addTableRow(index + 1, keyword, status, link);
    }

    function addTableRow(no, keyword, status, link) {
      document.querySelector("#results tbody").innerHTML += `
        <tr>
          <td>${no}</td>
          <td>${keyword}</td>
          <td>${status}</td>
          <td>${link}</td>
        </tr>`;
    }

    function getInputLines() {
      return document.getElementById("keywords").value.trim().split("\n").filter(x => x.trim() !== "");
    }

    function showStatusMessage(message, showSpinner) {
      document.getElementById("statusMessage").innerHTML = message + (showSpinner ? ' <div class="spinner"></div>' : '');
      document.getElementById("statusMessage").style.display = "block";
    }

    function delayExecution(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function toggleVisibility(hide) {
      document.getElementById("keywords").style.display = hide ? "none" : "block";
      document.querySelector("button").style.display = hide ? "none" : "block";
      document.getElementById("results").style.display = hide ? "table" : "none";
    }
  </script>
</body>
</html>
